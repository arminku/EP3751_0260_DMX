<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="MAIN" Id="{5ed6dd28-4e50-4912-a842-bd2821892fe5}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
(* Slave Information *)
	ECATState AT %I* : WORD;
	EcatPort AT %I* : WORD;
	netId : STRING(23);
	dNetID AT %I* : ARRAY [0..5] OF BYTE;

	Axis AT %I* : ARRAY [0..2] OF DINT;
	corrAxis : ARRAY [0..2] OF DINT;
	offset : ARRAY [0..2] OF DINT;

	Integrator : ARRAY [0..2] OF LREAL;
	Deg : ARRAY [0..2] OF LREAL;
	DegMovingHead : ARRAY [0..2] OF INT;
	z: INT;

	iFltValue : ARRAY [0..2] OF DINT;
	iFilter : ARRAY [0..2] OF FBiFilter;
	aFltArray : ARRAY [0..2] OF ARRAY [0..10000] OF DINT;
	
(* Accelerometer values *)
	AccAxis AT %I* : ARRAY [0..2] OF DINT;
	normalizedAcceleration : ARRAY [0..2] OF LREAL;

(* CoE Access *)
	WrCoe : FB_EcCoESdoWrite;
	RdCoe : FB_EcCoESdoRead;
	buf : POINTER TO INT;
	arBuf : ARRAY [0..5] OF BYTE;
	
(* Working variables *)
	slope : R_TRIG;
	bWriteOffset: BOOL;
	WriteOffsetState: INT;

	slopeResetCalibration : R_TRIG;
	bReset: BOOL;

	slopeResetAngle : R_TRIG;
	bResetAngle: BOOL;

	slopeReadFIFO : R_TRIG;
	bReadFIFO: BOOL;
	readFIFOState: INT;
	bytesToRead :INT := 1;
	rcvBytes : ARRAY [0..15] OF INT;
	bytesLeft: INT;
	
	dps : INT := 2000;
	
	(* state variables *)
	actualRoll : LREAL;
	actualPitch : LREAL;
	actualYaw : LREAL;
	
	actualPhi : LREAL;
	actualTheta : LREAL;
	actualGamma : LREAL;
		
	degPhi :INT;
	degTheta :INT;
	degGamma :INT;
	
	droll : LREAL;
	dpitch : LREAL;
	dyaw : LREAL;

	dphi : LREAL;
	dtheta : LREAL;
	dgamma : LREAL;

	temp : LREAL;
	
	AccPhi : LREAL;
	AccTheta : LREAL;
	
	sumAcc : LREAL;
	
	fusionWeight : LREAL := 1024;
	fusionWindow: INT := 50;
	fusionHorizontThreshold :LREAL := 0.4;
	fCycleTime 				: LREAL := 0.001; // in s


	//DMX
	stEL6851InData  AT%I*:  ST_EL6851InDataEx;
	stEL6851OutData AT%Q*: ST_EL6851OutData;
	stCommandBuffer : ST_DMXCommandBuffer;
	arrProcessData  : ARRAY [1..512] OF BYTE;
	
	fbDMX		: FB_EL6851CommunicationEx;
	aByte :array [1..2] of byte;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[FOR z := 0 TO 2 DO
	(* Integrate the gyro values to gain an overall angle -> this angle is RPY *)
	corrAxis[z] := Axis[z] - offset[z];
	
	(* ignore values greater that +/-32000 *)
	IF corrAxis[z] > 32000 THEN corrAxis[z] := 0; END_IF;
	IF corrAxis[z] < -32000 THEN corrAxis[z] := 0; END_IF;

	Integrator[z] := Integrator[z] + (corrAxis[z] / ((1/fCycleTime)*(32768/dps)*90*4));
	Deg[z] := Integrator[z] * 360.0;
	DegMovingHead[z] := REAL_TO_INT(Deg[z]) MOD 360;

	(* Filter values for axis zero correction *)
	IF Axis[z] < 32000 AND Axis[z] > -32000 THEN
		iFilter[z](ptInputValue := ADR(Axis[z]), ptFilterArray := ADR(aFltArray[z]), iBufferSize := 2000, bExecute := 1);
		iFltValue[z] := iFilter[z].iFilterOutput;
	END_IF;
END_FOR

(* calculate the delta movements *)
droll := actualRoll;
dpitch := actualPitch;
dyaw := actualYaw;

actualRoll := (Deg[0] /360) * 2 * PI;
actualPitch := (Deg[1] /360) * 2 * PI;
actualYaw := (Deg[2] /360) * 2 * PI;

droll := actualRoll - droll;
dpitch := actualPitch - dpitch;
dyaw := actualYaw - dyaw;

(* Axis correction *)
dyaw := -dyaw;
temp := dpitch;
dpitch := droll;
droll := temp;

(* Calculate the euler speeds *)
dphi := droll + SIN(actualPhi)*TAN(actualTheta)*dpitch + COS(actualPhi)*TAN(actualTheta)*dyaw;
dtheta := COS(actualPhi)*dpitch-SIN(actualPhi)*dyaw;
dgamma := (SIN(actualPhi)/COS(actualTheta)) * dpitch + (COS(actualPhi)/COS(actualTheta)) * dyaw;

(* Calculate new euler angles *)
actualPhi := actualPhi + dphi;
actualTheta := actualTheta + dtheta;
actualGamma := actualGamma + dgamma;

(* Collapse if passing thresholds of pi *)
IF actualPhi < 0 THEN
	actualPhi := actualPhi + 2*PI;
END_IF
IF actualPhi >= 2*PI THEN
	actualPhi := actualPhi - 2*PI;
END_IF
IF actualTheta < 0 THEN
	actualTheta := actualTheta + 2*PI;
END_IF
IF actualTheta >= 2*PI THEN
	actualTheta := actualTheta - 2*PI;
END_IF
IF actualGamma < 0 THEN
	actualGamma := actualGamma + 2*PI;
END_IF
IF actualGamma >= 2*PI THEN
	actualGamma := actualGamma - 2*PI;
END_IF

(* Determine length of acceleration vector *)
sumAcc := AccAxis[0] * AccAxis[0] + AccAxis[1] * AccAxis[1] + AccAxis[2] * AccAxis[2];
sumAcc := SQRT(sumAcc);

(* Normalize acceleration vector *)
IF sumAcc <> 0 THEN
	FOR z := 0 TO 2 DO
		normalizedAcceleration[z] := AccAxis[z] / sumAcc;
	END_FOR
END_IF

(* Due to normalized values, we do no need to cut off higher values than 1 *)
IF normalizedAcceleration[2] = 0 THEN
	normalizedAcceleration[2] := 0.000001;
END_IF
AccPhi := -ATAN(normalizedAcceleration[0] / normalizedAcceleration[2]) + PI;
IF (AccAxis[2]) >=0 THEN
	AccPhi := AccPhi + PI;
END_IF
IF AccPhi > 2*PI THEN AccPhi := AccPhi - 2*PI; END_IF;
IF AccPhi < 0 THEN AccPhi := AccPhi + 2*PI; END_IF;
AccTheta := ASIN(normalizedAcceleration[1]) + PI;
(* Simple sensor fusion if we are not accelerated *)
IF sumAcc >= (2048 - fusionWindow) AND sumAcc <= (2048 + fusionWindow) THEN
	(* The AccPhi calculation is good, as long as Axis[2] ist not close to 0 *)
	IF normalizedAcceleration[2] < -fusionHorizontThreshold OR normalizedAcceleration[2] > fusionHorizontThreshold THEN
		IF (actualPhi - AccPhi) > PI OR (actualPhi - AccPhi) < -PI THEN
			IF AccPhi > actualPhi THEN
				AccPhi := AccPhi - 2 * PI;
			ELSE
				AccPhi := AccPhi + 2 * PI;
			END_IF
		END_IF
		actualPhi := ((fusionWeight-1) * actualPhi + AccPhi) /fusionWeight;
		(* error Zero crossing nicht beachtet!!! *)
	END_IF
	(* AccTheta is always accurate *)
	actualTheta := ((fusionWeight-1) * actualTheta + AccTheta) /fusionWeight;
END_IF

slope(CLK := bWriteOffset);
IF slope.Q THEN
	IF WriteOffsetState = 0 THEN
		WriteOffsetState := 0;
		FOR z := 0 TO 2 DO
			offset[z] := iFltValue[z];
			Integrator[z] := 0.5; 
		END_FOR
	END_IF;
END_IF

slopeResetCalibration(CLK := bReset);
IF slopeResetCalibration.Q THEN
	FOR z := 0 TO 2 DO
		offset[z] := 0;
		iFilter[z](bExecute := 0);
	END_FOR
END_IF

slopeResetAngle(CLK := bResetAngle);
IF slopeResetAngle.Q THEN
	FOR z := 0 TO 2 DO
		Integrator[z] := 0.5;
		actualRoll := PI;
		actualPitch := PI;
		actualYaw := PI;
		
		actualPhi := PI;
		actualTheta := PI;
		actualGamma := PI;
	END_FOR
END_IF

slopeReadFIFO(CLK := bReadFIFO);
IF slopeReadFIFO.Q THEN
	readFIFOState := 1;
	bytesLeft := bytesToRead;
END_IF

// calculation rad --> degree
degPhi 		:= TO_INT(actualPhi *360 /(2*PI));
degTheta	:= TO_INT(actualTheta *360 /(2*PI));
degGamma	:= TO_INT(actualGamma *360 /(2*PI));

DMX();]]></ST>
    </Implementation>
    <Action Name="DMX" Id="{4a0ef7b0-5867-4ba8-a77d-b2ec24109e32}">
      <Implementation>
        <ST><![CDATA[//values depended on which box is used
//arrProcessData[1]:= TO_BYTE(LIMIT(0,(EP3751_0160_X*128/1100)+128,255));
//arrProcessData[2]:= TO_BYTE(LIMIT(0,(EP3751_0160_Y*128/1100)+128,255));

//arrProcessData[1]:= TO_BYTE(LIMIT(0,(EP3751_0260_X*128/1100)+128,255));
//arrProcessData[2]:= TO_BYTE(LIMIT(0,(EP3751_0260_rX*128/1100)+128,255));
//memcpy(ADR(aByte),ADR(corrAxis[2]),2);

arrProcessData[1]:= TO_BYTE(LIMIT(0,((actualGamma)*170/(2*PI)),255));
arrProcessData[2]:= TO_BYTE(LIMIT(0,((2*actualTheta-1.9*PI)*235/(2*PI)),255)); // 0..255
//arrProcessData[1]:=LIMIT(0,TO_BYTE(arrProcessData[1]+(-1*corrAxis[2]/1000)),255);
//arrProcessData[1]:=arrProcessData[1];
//arrProcessData[2]:=arrProcessData[2];
//static values
arrProcessData[3]:= 10;
arrProcessData[5]:= 255;
arrProcessData[6]:= 255;

fbDMX(
	wSourceManufacturerId:= 16#42_41, 
	dwSourceDeviceId:= 16#12_13_14_15, 
	bEnableSendingData:= TRUE, 
	bSetCycleMode:=TRUE , 
	bSendDefaultData:= , 
	uiDataLength:= 64 , 
	dwOptions:=  , 
	stEL6851InData:=	stEL6851InData , 
	stEL6851OutData:= 	stEL6851OutData, 
	stCommandBuffer:= 	stCommandBuffer, 
	arrProcessData:=	arrProcessData);

]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="MAIN">
      <LineId Id="594" Count="6" />
      <LineId Id="932" Count="0" />
      <LineId Id="602" Count="137" />
      <LineId Id="834" Count="3" />
      <LineId Id="35" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.DMX">
      <LineId Id="21" Count="4" />
      <LineId Id="2" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="3" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="4" Count="16" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>